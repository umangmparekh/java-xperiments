Index: src/main/java/org/example/PalindromePermutations.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.example;public class PalindromePermutations {\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/example/PalindromePermutations.java b/src/main/java/org/example/PalindromePermutations.java
--- a/src/main/java/org/example/PalindromePermutations.java	(revision b8c5ad5eee4812ccd646a6d3928787c203f99027)
+++ b/src/main/java/org/example/PalindromePermutations.java	(date 1754827448032)
@@ -1,2 +1,64 @@
-package org.example;public class PalindromePermutations {
+package org.example;
+
+/**
+ *
+ * Given a string, write a function to check if it is a permutation of a palindrome.
+ *
+ * A palindrome is a word or phrase that is the same forwards and backwards.
+ * A permutation is a rearrangement of letters.
+ * The palindrome doesn’t need to be limited to just dictionary words.
+ *
+ * For a string to be a permutation of a palindrome:
+ * Each character must appear an even number of times,
+ * Except for at most one character, which can appear an odd number of times (middle character in odd-length palindrome).
+ *
+ *💡 Steps:
+ * Ignore spaces and make characters lowercase.
+ * Count occurrences of each character.
+ * Check that at most one character has an odd count.
+ *
+ *
+ * Code Recap:
+ * We use an int[] table of fixed size (128 for ASCII)
+ * Loop once to count characters (O(n))
+ * Loop again to check counts (O(1) since table size is constant)
+ *
+ * Time Complexity:
+ * O(n) → We scan the string once (n = number of characters in input)
+ *
+ * Space Complexity:
+ * O(1) → The int[] table has constant size (128), so memory usage does not grow with n
+ *
+ * Time Complexity : O(n)
+ * Space Complexity : O(1)
+ */
+public class PalindromePermutations {
+
+    public  static boolean isPalindromePermutation(String str){
+        int[] table = new int[128]; // ASCII table size
+        str = str.toLowerCase();
+
+        for (char c : str.toCharArray()) {
+            if (c != ' ') {
+                table[c]++;
+            }
+        }
+
+        boolean foundOdd = false;
+        for (int count : table) {
+            System.out.println("Count >> "+count);
+            if (count % 2 != 0) {
+                if (foundOdd) {
+                    return false;
+                }
+                foundOdd = true;
+            }
+        }
+        return true;
+    }
+
+    public static void main(String[] args) {
+        System.out.println(isPalindromePermutation("Tact Coa")); // true ("taco cat", "atco cta")
+        System.out.println(isPalindromePermutation("Hellooe"));    // false
+    }
 }
Index: src/main/java/org/example/URLify.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.example;public class URLify {\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/example/URLify.java b/src/main/java/org/example/URLify.java
--- a/src/main/java/org/example/URLify.java	(revision b8c5ad5eee4812ccd646a6d3928787c203f99027)
+++ b/src/main/java/org/example/URLify.java	(date 1754827408777)
@@ -1,2 +1,57 @@
-package org.example;public class URLify {
+package org.example;
+
+/**
+ *
+ * Write a method to replace all spaces in a string with %20.
+ * You may assume that the string has sufficient space at the end to hold the additional characters, and that you are given the "true" length of the string.
+ *
+ *Time Complexity
+ * O(n) — where n is the true length of the string
+ *
+ * We scan the string once to count spaces (O(n)) and once more to replace spaces from the end (O(n))
+ * Combined: O(n) + O(n) → O(n)
+ *
+ * Space Complexity
+ * O(1) — we modify the array in place without using extra space proportional to n
+ * Just a few integer variables for counters
+ */
+public class URLify {
+
+    public static void main(String arg[]){
+
+        String input = "Mr Umang Parekh    ";
+        int inputLength = 15;
+        char[] charArray = input.toCharArray();
+        replaceSpaces(charArray, inputLength);
+
+        System.out.println("\"" + new String(charArray) + "\"");
+    }
+
+
+    public static void replaceSpaces(char[] str, int inputLength) {
+        int spaceCount = 0;
+        for (int i = 0; i < inputLength; i++) {
+            if(str[i]==' ') spaceCount++;
+        }
+        System.out.println(" Space count char '"+spaceCount+"'");
+
+        int index = inputLength + spaceCount * 2;
+        // If there’s extra space at the end
+        if (inputLength < str.length) str[inputLength] = '\0';
+        System.out.println("\"" + new String(str) + "\"");
+
+        // Replace spaces from end
+        for (int i = inputLength - 1; i >= 0; i--) {
+            System.out.println(" Operating char '"+str[i]+"'");
+            if (str[i] == ' ') {
+                str[index - 1] = '0';
+                str[index - 2] = '2';
+                str[index - 3] = '%';
+                index -= 3;
+            } else {
+                str[index - 1] = str[i];
+                index--;
+            }
+        }
+    }
 }
Index: src/main/java/org/example/StringRotation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.example;public class StringRotation {\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/example/StringRotation.java b/src/main/java/org/example/StringRotation.java
--- a/src/main/java/org/example/StringRotation.java	(revision b8c5ad5eee4812ccd646a6d3928787c203f99027)
+++ b/src/main/java/org/example/StringRotation.java	(date 1754851800529)
@@ -1,2 +1,47 @@
-package org.example;public class StringRotation {
+package org.example;
+
+/**
+ *
+ * Problem Statement
+ * Check if one string is a rotation of another using only one call to isSubstring.
+ *
+ * Input:
+ * s1 = "waterbottle"
+ * s2 = "erbottlewat"
+ *
+ * Output:
+ * true   // because "erbottlewat" is a rotation of "waterbottle"
+ *
+ * Idea :
+ * Key Insight
+ * If s2 is a rotation of s1, then it will always be a substring of s1 + s1.
+ *
+ * s1 = waterbottle
+ * s1 + s1 = waterbottlewaterbottle
+ *
+ * s2 = erbottlewat
+ * "erbottlewat" is inside "waterbottlewaterbottle"
+ *
+ * Time & Space Complexity
+ * Time Complexity:
+ * O(N) — where N is the string length; contains typically uses KMP or similar search.
+ * Space Complexity:
+ * O(N) — for storing s1 + s1.
+ *
+ *
+ */
+public class StringRotation {
+    public static boolean isRotation(String s1, String s2) {
+        if (s1.length() != s2.length() || s1.length() == 0) {
+            return false;
+        }
+        String s1s1 = s1 + s1;
+        return s1s1.contains(s2); // single call to isSubstring
+    }
+    public static void main(String[] args) {
+        System.out.println(isRotation("waterbottle", "erbottlewat")); // true
+        System.out.println(isRotation("hello", "llohe")); // true
+        System.out.println(isRotation("hello", "ohellx")); // false
+    }
+
 }
Index: src/main/java/org/example/ZeroMatrix.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.example;public class ZeroMatrix {\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/example/ZeroMatrix.java b/src/main/java/org/example/ZeroMatrix.java
--- a/src/main/java/org/example/ZeroMatrix.java	(revision b8c5ad5eee4812ccd646a6d3928787c203f99027)
+++ b/src/main/java/org/example/ZeroMatrix.java	(date 1754851432367)
@@ -1,2 +1,55 @@
-package org.example;public class ZeroMatrix {
+package org.example;
+
+public class ZeroMatrix {
+
+    public static void setZeroes(int[][] matrix) {
+        int m = matrix.length;
+        int n = matrix[0].length;
+
+        boolean[] rows = new boolean[m];
+        boolean[] cols = new boolean[n];
+
+        // Step 1: Mark rows and columns
+        for (int i = 0; i < m; i++) {
+            for (int j = 0; j < n; j++) {
+                if (matrix[i][j] == 0) {
+                    rows[i] = true;
+                    cols[j] = true;
+                }
+            }
+        }
+
+        // Step 2: Zero out rows
+        for (int i = 0; i < m; i++) {
+            if (rows[i]) {
+                for (int j = 0; j < n; j++) {
+                    matrix[i][j] = 0;
+                }
+            }
+        }
+
+        // Step 3: Zero out columns
+        for (int j = 0; j < n; j++) {
+            if (cols[j]) {
+                for (int i = 0; i < m; i++) {
+                    matrix[i][j] = 0;
+                }
+            }
+        }
+    }
+    public static void main(String[] args) {
+        int[][] matrix = {
+                {1,  2,  3, 4},
+                {5,  0,  7, 8},
+                {9,  10,  11, 12},
+                {13, 14, 15, 16}
+        };
+        setZeroes(matrix);
+        for (int[] row : matrix) {
+            for (int val : row) {
+                System.out.print(val + " ");
+            }
+            System.out.println();
+        }
+    }
 }
Index: src/main/java/org/example/CheckPermutationV1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.example;public class CheckPermutationV1 {\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/example/CheckPermutationV1.java b/src/main/java/org/example/CheckPermutationV1.java
--- a/src/main/java/org/example/CheckPermutationV1.java	(revision b8c5ad5eee4812ccd646a6d3928787c203f99027)
+++ b/src/main/java/org/example/CheckPermutationV1.java	(date 1754433236162)
@@ -1,2 +1,57 @@
-package org.example;public class CheckPermutationV1 {
+package org.example;
+
+import java.util.Arrays;
+
+/**
+ *     Problem : Given two strings, write a method to decide if one is a permutation of the other.
+ *     Solution: Sort Both Strings
+ *
+ */
+public class CheckPermutationV1 {
+
+    public static void main(String arg[]){
+
+        String str1 = "Umang";
+        String str2 = "manUg";
+        System.out.println("Version 1 : Sorting");
+        System.out.println("Check string permutation for String 1 :"+str1+" & String 2 :"+str2);
+        System.out.println("Result : "+CheckPermutation(str1, str2));
+
+        System.out.println("Version 2 : Count Characters");
+        System.out.println("Check string permutation for String 1 :"+str1+" & String 2 :"+str2);
+        System.out.println("Result : "+CheckPermutationNext(str1, str2));
+    }
+
+    public static boolean CheckPermutationNext(String str1, String str2) {
+        if(str1.length() != str2.length())
+            return false;
+
+        int[] letters = new int[128]; // ASCII
+
+        for(int i=0;i<str1.length();i++){
+            letters[str1.charAt(i)]++;
+        }
+
+        for(int j=0;j<str2.length();j++){
+            letters[str2.charAt(j)]--;
+            if(letters[str2.charAt(j)]<0)
+                    return false;
+        }
+
+        return true;
+    }
+    public static boolean CheckPermutation(String str1, String str2) {
+
+        if(str1.length() != str2.length())
+            return false;
+
+        char[] array1 = str1.toCharArray();
+        char[] array2 = str2.toCharArray();
+
+        Arrays.sort(array1);
+        Arrays.sort(array2);
+
+        return Arrays.equals(array1, array2);
+
+    }
 }
Index: src/main/java/org/example/RotateMatrix.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.example;public class RotateMatrix {\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/example/RotateMatrix.java b/src/main/java/org/example/RotateMatrix.java
--- a/src/main/java/org/example/RotateMatrix.java	(revision b8c5ad5eee4812ccd646a6d3928787c203f99027)
+++ b/src/main/java/org/example/RotateMatrix.java	(date 1754850517496)
@@ -1,2 +1,59 @@
-package org.example;public class RotateMatrix {
+package org.example;
+
+/**
+ *
+ * Given an N x N matrix, write a method to rotate the matrix by 90 degrees in place.
+ *
+ * Idea:
+ * Rotate the matrix layer by layer.
+ * Outer layer → swap elements from top, right, bottom, left.
+ * Then move inward to the next layer.
+ *
+ * ⏳ Time Complexity
+ * O(n²) → We touch each element once
+ * 💾 Space Complexity
+ * O(1) → Rotation is done in place, no extra space proportional to n
+ */
+public class RotateMatrix {
+
+    public static boolean rotate(int[][] matrix){
+        if (matrix.length == 0 || matrix.length != matrix[0].length) return false; // Must be NxN
+        int n = matrix.length;
+        System.out.println("Matrix length > "+ n);
+        for(int layer=0; layer < n/2; layer++){
+            int first = layer;
+            int last = n-1-layer;
+
+            for(int i=first; i<last; i++){
+                int offset = i - first;
+                int top = matrix[first][i];
+                System.out.println("i >> "+i+" layer >>"+layer+" first > "+first+" last >>"+last+" offset >>"+offset+" top >>"+top+" last-offset >> "+(last-offset));
+                // left -> top
+                matrix[first][i] = matrix[last - offset][first];
+                // bottom -> left
+                matrix[last - offset][first] = matrix[last][last - offset];
+                // right -> bottom
+                matrix[last][last - offset] = matrix[i][last];
+                // top -> right
+                matrix[i][last] = top;
+            }
+        }
+        return true;
+
+    }
+    public static void main(String[] args) {
+        int[][] matrix = {
+                {1,  2,  3, 4},
+                {5,  6,  7, 8},
+                {9,  10,  11, 12},
+                {13, 14, 15, 16}
+        };
+        rotate(matrix);
+        for (int[] row : matrix) {
+            for (int val : row) {
+                System.out.print(val + " ");
+            }
+            System.out.println();
+        }
+    }
 }
Index: src/main/java/org/example/ArrayIsUnique.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.example;public class ArrayIsUnique {\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/example/ArrayIsUnique.java b/src/main/java/org/example/ArrayIsUnique.java
--- a/src/main/java/org/example/ArrayIsUnique.java	(revision b8c5ad5eee4812ccd646a6d3928787c203f99027)
+++ b/src/main/java/org/example/ArrayIsUnique.java	(date 1754432525295)
@@ -1,2 +1,34 @@
-package org.example;public class ArrayIsUnique {
+package org.example;
+
+/**
+ * Implement an algorithm to determine if a string has all unique characters.
+ * What if you cannot use additional data structures?
+ *
+ * Time Complexity:
+ * O(n2) — where n is the length of the string
+ * Space: O(1) for the set
+ */
+public class ArrayIsUnique {
+
+    public static void main(String arg[]){
+
+        String checkUniqueString = "isUniqueStringOrNot";
+        System.out.println("String  "+checkUniqueString+" | is unique :>>> "+isUnique(checkUniqueString));
+    }
+
+    public static boolean isUnique(String checkStr){
+
+        int length = checkStr.length();
+
+        for(int i=0; i<length; i++){
+            for(int j=i+1; j<length; j++){
+                if(checkStr.charAt(i)==checkStr.charAt(j)){
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
 }
Index: src/main/java/org/example/StringCompression.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.example;public class StringCompression {\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/example/StringCompression.java b/src/main/java/org/example/StringCompression.java
--- a/src/main/java/org/example/StringCompression.java	(revision b8c5ad5eee4812ccd646a6d3928787c203f99027)
+++ b/src/main/java/org/example/StringCompression.java	(date 1754833085863)
@@ -1,2 +1,46 @@
-package org.example;public class StringCompression {
+package org.example;
+
+/**
+ *
+ * Implement a method to perform basic string compression using the counts of repeated characters.
+ * Example:
+ * "aabcccccaaa" → "a2b1c5a3"
+ * If the compressed string would not be smaller than the original, return the original string.
+ *
+ *
+ *
+ * Time Complexity
+ * O(n) — We scan the string once
+ * Building the new string is proportional to n
+ * Space Complexity
+ * O(n) — StringBuilder stores up to twice the original string length in worst case
+ */
+public class StringCompression {
+
+    public static String CompressedString(String str){
+
+        StringBuilder compressed = new StringBuilder();
+        int countConsecutive = 0;
+        for (int i = 0; i < str.length(); i++) {
+            countConsecutive++;
+
+            // If next char is different or end of string, append this char and count
+            if (i + 1 >= str.length() || str.charAt(i) != str.charAt(i + 1)) {
+                compressed.append(str.charAt(i));
+                compressed.append(countConsecutive);
+                countConsecutive = 0;
+            }
+        }
+
+        // Return the shorter one
+        return compressed.length() < str.length() ? compressed.toString() : str;
+    }
+    public static void main(String[] args) {
+        String str1 = "pale";
+        System.out.println(CompressedString(str1));
+        String str2 = "aabcccccaaa";
+        System.out.println(CompressedString(str2));
+
+    }
+
 }
Index: src/main/java/org/example/OneAway_CTCI.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.example;public class OneAway_CTCI {\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/example/OneAway_CTCI.java b/src/main/java/org/example/OneAway_CTCI.java
--- a/src/main/java/org/example/OneAway_CTCI.java	(revision b8c5ad5eee4812ccd646a6d3928787c203f99027)
+++ b/src/main/java/org/example/OneAway_CTCI.java	(date 1754831148947)
@@ -1,2 +1,76 @@
-package org.example;public class OneAway_CTCI {
+package org.example;
+
+/**
+ *
+ * Write a function to check if two strings are one edit (or zero edits) away from each other.
+ * An edit is:
+ * Insert a character
+ * Remove a character
+ * Replace a character
+ *
+ *
+ * If lengths differ by more than 1 → false.
+ * If lengths are equal → check for at most one replacement.
+ * If lengths differ by 1 → check for at most one insertion/removal.
+ *
+ * ⏳ Time Complexity:
+ * O(n) where n is the length of the shorter string
+ * We scan both strings at most once
+ * 💾 Space Complexity:
+ * O(1) — only a few extra variables
+ */
+public class OneAway_CTCI {
+
+    public static boolean isOneAway(String first, String second) {
+        if (Math.abs(first.length() - second.length()) > 1) {
+            return false;
+        }
+        // Same length → check replacement
+        if (first.length() == second.length()) {
+            return oneEditReplace(first, second);
+        }
+
+        // Length differs → check insert/remove
+        else if (first.length() + 1 == second.length()) {
+            return oneEditInsert(first, second);
+        } else if (first.length() - 1 == second.length()) {
+            return oneEditInsert(second, first);
+        }
+
+        return false;
+
+    }
+
+    private static boolean oneEditReplace(String s1, String s2) {
+        boolean foundDifference = false;
+        for (int i = 0; i < s1.length(); i++) {
+            if (s1.charAt(i) != s2.charAt(i)) {
+                if (foundDifference) return false;
+                foundDifference = true;
+            }
+        }
+        return true;
+    }
+
+    private static boolean oneEditInsert(String shorter, String longer) {
+        int index1 = 0;
+        int index2 = 0;
+        while (index1 < shorter.length() && index2 < longer.length()) {
+            if (shorter.charAt(index1) != longer.charAt(index2)) {
+
+                if (index1 != index2) return false;
+                index2++;
+            } else {
+                index1++;
+                index2++;
+            }
+        }
+        return true;
+    }
+    public static void main(String[] args) {
+        String str1 = "pale";
+        String str2 = "ple";
+
+        System.out.println(isOneAway(str1, str2));
+    }
 }
